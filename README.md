Було проведено навантажувальне тестування на вибірку даних пацієнта.
MSSQL 0.0359 sec, join запит
MongoDB 0.1097 sec, single document fetch
У даному тесті MS SQL Server виявився швидшим (приблизно в 3 рази). Це пояснюється наступними факторами:
Обсяг даних: Тестування проводилося на вибірці у 1000 пацієнтів. Такий обсяг даних MS SQL повністю кешує в оперативній пам'яті, а оптимізатор запитів SQL Server надзвичайно ефективно працює з малими наборами даних.
Накладні витрати драйвера: Для MongoDB передача великого JSON-об'єкта та його десеріалізація в Python (бібліотека pymongo) на малих обсягах може займати більше процесорного часу, ніж робота оптимізованого драйвера pyodbc через Shared Memory протокол.
Хоча MongoDB показала меншу "сиру" швидкість на малому наборі даних, її використання залишається доцільним через гнучкість схеми (можливість додавати будь-які поля в історію хвороби без зміни структури БД).
Також я використовував Redis для реалізації задачі реального часу - панель чергового лікаря. Для цього я зробив запис критичного стану пацієнта, інкрементацію лічильника черги та миттєве зчитування статусу для дашборда.

Для перегляду коду бенчмарків можна переглянути benchmark.py та redisBench.py у RUoW проєкті.
Вивід програм:
Redis:
--- Redis Use Case: Real-time ER Dashboard ---
Written status for patient:101 to cache.
New patient arrived. Queue size: 6
DASHBOARD ALERT: Patient Ivanov I. is in Critical condition!

Performed 10,000 reads in 2.8630 seconds.
Avg time per read: 0.000286 seconds.

MongoDB vs MSSQL:
Running MS SQL Benchmark...
MS SQL Time: 0.0359 sec
Running MongoDB Benchmark...
MongoDB Time: 0.1097 sec